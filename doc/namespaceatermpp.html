<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ATermLib: atermpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ATermLib
   </div>
   <div id="projectbrief">Standalone ATerm library extracted from mCRL2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceatermpp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atermpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main namespace for the aterm++ library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceatermpp_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1aterm.html">aterm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1aterm__int.html">aterm_int</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1aterm__string.html">aterm_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term containing a string.  <a href="classatermpp_1_1aterm__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1builder.html">builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1disable__if__container.html">disable_if_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1enable__if__container.html">enable_if_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1function__symbol__generator.html">function_symbol_generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates unique function symbols with a given prefix.  <a href="classatermpp_1_1function__symbol__generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1idle__transformer.html">idle_transformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1indexed__set.html">indexed_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed set.  <a href="classatermpp_1_1indexed__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1is__container.html">is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1is__container_3_01_t_00_01void_01_4.html">is_container&lt; T, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1is__set.html">is_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1read__todo.html">read_todo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1sym__read__entry.html">sym_read_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1sym__write__entry.html">sym_write_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1term__appl.html">term_appl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1term__appl__iterator.html">term_appl_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for <a class="el" href="classatermpp_1_1term__appl.html">term_appl</a>.  <a href="classatermpp_1_1term__appl__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1term__balanced__tree.html">term_balanced_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only balanced binary tree of terms.  <a href="classatermpp_1_1term__balanced__tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1term__list.html">term_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1term__list__iterator.html">term_list_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for <a class="el" href="classatermpp_1_1term__list.html">term_list</a>.  <a href="classatermpp_1_1term__list__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1top__symbol.html">top_symbol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatermpp_1_1top__symbols__t.html">top_symbols_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1unary__template__swap.html">unary_template_swap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatermpp_1_1write__todo.html">write_todo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa8340a152b723553c64027b12195988b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a>) (const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;)</td></tr>
<tr class="separator:aa8340a152b723553c64027b12195988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b700cb63038bdfad10397351fca4b05"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classatermpp_1_1term__appl.html">term_appl</a>&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a></td></tr>
<tr class="separator:a5b700cb63038bdfad10397351fca4b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9713fa8ce931c3a2cd8aa5bfb75a1d1d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classatermpp_1_1term__balanced__tree.html">term_balanced_tree</a>&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a9713fa8ce931c3a2cd8aa5bfb75a1d1d">aterm_balanced_tree</a></td></tr>
<tr class="memdesc:a9713fa8ce931c3a2cd8aa5bfb75a1d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classatermpp_1_1term__balanced__tree.html" title="Read-only balanced binary tree of terms. ">term_balanced_tree</a> with elements of type aterm.  <a href="#a9713fa8ce931c3a2cd8aa5bfb75a1d1d">More...</a><br /></td></tr>
<tr class="separator:a9713fa8ce931c3a2cd8aa5bfb75a1d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61bb12f97e6fedfb20a50cb6bc4342d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#aa61bb12f97e6fedfb20a50cb6bc4342d">aterm_list</a></td></tr>
<tr class="memdesc:aa61bb12f97e6fedfb20a50cb6bc4342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classatermpp_1_1term__list.html">term_list</a> with elements of type aterm.  <a href="#aa61bb12f97e6fedfb20a50cb6bc4342d">More...</a><br /></td></tr>
<tr class="separator:aa61bb12f97e6fedfb20a50cb6bc4342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992fc95b7153020c7a6005380e05d18d"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::pair&lt; const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> *, <a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a992fc95b7153020c7a6005380e05d18d">hook_table</a></td></tr>
<tr class="separator:a992fc95b7153020c7a6005380e05d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a898b19ee30d566b679beb29155cb6c0a"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction , typename Term &gt; </td></tr>
<tr class="memitem:a898b19ee30d566b679beb29155cb6c0a"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a898b19ee30d566b679beb29155cb6c0a">for_each</a> (Term t, UnaryFunction op)</td></tr>
<tr class="memdesc:a898b19ee30d566b679beb29155cb6c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls op(elem) for subterms of the term t.  <a href="#a898b19ee30d566b679beb29155cb6c0a">More...</a><br /></td></tr>
<tr class="separator:a898b19ee30d566b679beb29155cb6c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f43e950f6b74d5433f66a5809d28f38"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename MatchPredicate &gt; </td></tr>
<tr class="memitem:a5f43e950f6b74d5433f66a5809d28f38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a5f43e950f6b74d5433f66a5809d28f38">find_if</a> (const Term &amp;t, MatchPredicate match)</td></tr>
<tr class="memdesc:a5f43e950f6b74d5433f66a5809d28f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a subterm of t that matches a given predicate.  <a href="#a5f43e950f6b74d5433f66a5809d28f38">More...</a><br /></td></tr>
<tr class="separator:a5f43e950f6b74d5433f66a5809d28f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc8c98070bdcd776cb2721ccc3632d9"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename MatchPredicate , typename StopPredicate &gt; </td></tr>
<tr class="memitem:a5cc8c98070bdcd776cb2721ccc3632d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a5cc8c98070bdcd776cb2721ccc3632d9">partial_find_if</a> (Term t, MatchPredicate match, StopPredicate stop)</td></tr>
<tr class="memdesc:a5cc8c98070bdcd776cb2721ccc3632d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a subterm of t that matches a given predicate. The term is only partially traversed. If the stop predicate returns true in a subterm, the recursion is not continued.  <a href="#a5cc8c98070bdcd776cb2721ccc3632d9">More...</a><br /></td></tr>
<tr class="separator:a5cc8c98070bdcd776cb2721ccc3632d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df8950ad9b80e31c056844b7352400a"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename MatchPredicate , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a8df8950ad9b80e31c056844b7352400a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a8df8950ad9b80e31c056844b7352400a">find_all_if</a> (const Term &amp;t, MatchPredicate match, OutputIterator destBegin)</td></tr>
<tr class="memdesc:a8df8950ad9b80e31c056844b7352400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all subterms of t that match a given predicate, and writes the found terms to the destination range starting with destBegin.  <a href="#a8df8950ad9b80e31c056844b7352400a">More...</a><br /></td></tr>
<tr class="separator:a8df8950ad9b80e31c056844b7352400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42adae5d62bb383d526ce6f704b35613"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename MatchPredicate , typename StopPredicate , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a42adae5d62bb383d526ce6f704b35613"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a42adae5d62bb383d526ce6f704b35613">partial_find_all_if</a> (Term t, MatchPredicate match, StopPredicate stop, OutputIterator destBegin)</td></tr>
<tr class="memdesc:a42adae5d62bb383d526ce6f704b35613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all subterms of t that match a given predicate, and writes the found terms to the destination range starting with destBegin. The term is only partially traversed. If the stop predicate returns true in a subterm, the recursion is not continued.  <a href="#a42adae5d62bb383d526ce6f704b35613">More...</a><br /></td></tr>
<tr class="separator:a42adae5d62bb383d526ce6f704b35613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e12c8977c14259febf5a2fc0ba5815"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename ReplaceFunction &gt; </td></tr>
<tr class="memitem:a00e12c8977c14259febf5a2fc0ba5815"><td class="memTemplItemLeft" align="right" valign="top">Term&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a00e12c8977c14259febf5a2fc0ba5815">replace</a> (const Term &amp;t, ReplaceFunction r)</td></tr>
<tr class="memdesc:a00e12c8977c14259febf5a2fc0ba5815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each subterm x of t by r(x). The ReplaceFunction r has the following signature: aterm_appl x; aterm_appl result = r(x); The replacements are performed in top down order.  <a href="#a00e12c8977c14259febf5a2fc0ba5815">More...</a><br /></td></tr>
<tr class="separator:a00e12c8977c14259febf5a2fc0ba5815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b2ad54448e868e63f214e77119ea63"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:a13b2ad54448e868e63f214e77119ea63"><td class="memTemplItemLeft" align="right" valign="top">Term&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a13b2ad54448e868e63f214e77119ea63">replace</a> (const Term &amp;t, const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;old_value, const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;new_value)</td></tr>
<tr class="memdesc:a13b2ad54448e868e63f214e77119ea63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each subterm in t that is equal to old_value with new_value. The replacements are performed in top down order. For example, replace(f(f(x)), f(x), x) returns f(x) and not x.  <a href="#a13b2ad54448e868e63f214e77119ea63">More...</a><br /></td></tr>
<tr class="separator:a13b2ad54448e868e63f214e77119ea63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93a917e75091f807859dcf7b0e091cb"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename ReplaceFunction &gt; </td></tr>
<tr class="memitem:ae93a917e75091f807859dcf7b0e091cb"><td class="memTemplItemLeft" align="right" valign="top">Term&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#ae93a917e75091f807859dcf7b0e091cb">bottom_up_replace</a> (Term t, ReplaceFunction r)</td></tr>
<tr class="memdesc:ae93a917e75091f807859dcf7b0e091cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each subterm x of t by r(x). The ReplaceFunction r has the following signature: aterm_appl x; aterm_appl result = r(x); The replacements are performed in bottom up order. For example, replace(f(f(x)), f(x), x) returns x.  <a href="#ae93a917e75091f807859dcf7b0e091cb">More...</a><br /></td></tr>
<tr class="separator:ae93a917e75091f807859dcf7b0e091cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc96c02d1c5f6f1bff2fe802b4e7205"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:a1fc96c02d1c5f6f1bff2fe802b4e7205"><td class="memTemplItemLeft" align="right" valign="top">Term&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a1fc96c02d1c5f6f1bff2fe802b4e7205">bottom_up_replace</a> (Term t, const <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a> &amp;old_value, const <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a> &amp;new_value)</td></tr>
<tr class="memdesc:a1fc96c02d1c5f6f1bff2fe802b4e7205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each subterm in t that is equal to old_value with new_value. The replacements are performed in top down order. For example, replace(f(f(x)), f(x), x) returns f(x) and not x.  <a href="#a1fc96c02d1c5f6f1bff2fe802b4e7205">More...</a><br /></td></tr>
<tr class="separator:a1fc96c02d1c5f6f1bff2fe802b4e7205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3a8b36a7b46d7f6c1d38aaae6341be"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename ReplaceFunction &gt; </td></tr>
<tr class="memitem:a9a3a8b36a7b46d7f6c1d38aaae6341be"><td class="memTemplItemLeft" align="right" valign="top">Term&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a9a3a8b36a7b46d7f6c1d38aaae6341be">partial_replace</a> (Term t, ReplaceFunction r)</td></tr>
<tr class="memdesc:a9a3a8b36a7b46d7f6c1d38aaae6341be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces subterms x of t by r(x). The replace function r returns an additional boolean value. This value is used to prevent further recursion. The ReplaceFunction r has the following signature: aterm_appl x; std::pair&lt;aterm_appl, bool&gt; result = r(x); result.first is the result r(x) of the replacement result.second denotes if the recursion should be continued The replacements are performed in top down order.  <a href="#a9a3a8b36a7b46d7f6c1d38aaae6341be">More...</a><br /></td></tr>
<tr class="separator:a9a3a8b36a7b46d7f6c1d38aaae6341be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0632f02a15bcd3d95b74f45c2b14a9"><td class="memTemplParams" colspan="2">template&lt;typename Term , typename ReplaceFunction &gt; </td></tr>
<tr class="memitem:a1c0632f02a15bcd3d95b74f45c2b14a9"><td class="memTemplItemLeft" align="right" valign="top">Term&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a1c0632f02a15bcd3d95b74f45c2b14a9">bottom_up_replace</a> (Term t, ReplaceFunction r, std::unordered_map&lt; <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a>, <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &gt; &amp;cache)</td></tr>
<tr class="memdesc:a1c0632f02a15bcd3d95b74f45c2b14a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each subterm x of t by r(x). The ReplaceFunction r has the following signature: aterm_appl x; aterm_appl result = r(x); The replacements are performed in bottom up order. For example, replace(f(f(x)), f(x), x) returns x.  <a href="#a1c0632f02a15bcd3d95b74f45c2b14a9">More...</a><br /></td></tr>
<tr class="separator:a1c0632f02a15bcd3d95b74f45c2b14a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd26eb507fca62396cd1caf9f7850ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#abd26eb507fca62396cd1caf9f7850ecb">add_creation_hook</a> (const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;, <a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a>)</td></tr>
<tr class="separator:abd26eb507fca62396cd1caf9f7850ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d8a98984bcc8e80186edc05b1e422e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#aa6d8a98984bcc8e80186edc05b1e422e">add_deletion_hook</a> (const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;, <a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a>)</td></tr>
<tr class="separator:aa6d8a98984bcc8e80186edc05b1e422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f5cf133903629de48bce98bcb9c205"><td class="memTemplParams" colspan="2">template&lt;class Derived , class Base &gt; </td></tr>
<tr class="memitem:a02f5cf133903629de48bce98bcb9c205"><td class="memTemplItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a02f5cf133903629de48bce98bcb9c205">down_cast</a> (const Base &amp;t, typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, Derived &gt;::value &amp;&amp;!std::is_base_of&lt; Derived, Base &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a02f5cf133903629de48bce98bcb9c205"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cheap cast from one aterm based type to another When casting one aterm based type into another, generally a new aterm is constructed, and the old one is destroyed. This can cause undesired overhead, for instance due to increasing and decreasing of reference counts. This cast changes the type, without changing the aterm itself. It can only be used if Base and Derived inherit from aterm, and contain no additional information than a single aterm.  <a href="#a02f5cf133903629de48bce98bcb9c205">More...</a><br /></td></tr>
<tr class="separator:a02f5cf133903629de48bce98bcb9c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4eca5ee653f9c38bdc02606abb4ae1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedCont , typename Base , template&lt; typename Elem &gt; class Cont&gt; </td></tr>
<tr class="memitem:aff4eca5ee653f9c38bdc02606abb4ae1"><td class="memTemplItemLeft" align="right" valign="top">const DerivedCont &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#aff4eca5ee653f9c38bdc02606abb4ae1">container_cast</a> (const Cont&lt; Base &gt; &amp;t, typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__container.html">is_container</a>&lt; DerivedCont &gt;::value &amp;&amp;std::is_same&lt; Cont&lt; typename DerivedCont::value_type &gt;, DerivedCont &gt;::value &amp;&amp;!std::is_base_of&lt; DerivedCont, Cont&lt; Base &gt; &gt;::value &amp;&amp;<a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, typename DerivedCont::value_type &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="separator:aff4eca5ee653f9c38bdc02606abb4ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819c47f61db4bf0134f12a54f4d355f0"><td class="memTemplParams" colspan="2">template&lt;class Derived , class Base &gt; </td></tr>
<tr class="memitem:a819c47f61db4bf0134f12a54f4d355f0"><td class="memTemplItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a819c47f61db4bf0134f12a54f4d355f0">vertical_cast</a> (const Base &amp;t, typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, Derived &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a819c47f61db4bf0134f12a54f4d355f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cast form an aterm derived class to a class that inherits in possibly multiple steps from this class.  <a href="#a819c47f61db4bf0134f12a54f4d355f0">More...</a><br /></td></tr>
<tr class="separator:a819c47f61db4bf0134f12a54f4d355f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bcf91e123479b0165baea4a8bfd518"><td class="memTemplParams" colspan="2">template&lt;typename DerivedCont , typename Base , template&lt; typename Elem &gt; class Cont&gt; </td></tr>
<tr class="memitem:ab4bcf91e123479b0165baea4a8bfd518"><td class="memTemplItemLeft" align="right" valign="top">const DerivedCont &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#ab4bcf91e123479b0165baea4a8bfd518">vertical_cast</a> (const Cont&lt; Base &gt; &amp;t, typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__container.html">is_container</a>&lt; DerivedCont &gt;::value &amp;&amp;std::is_same&lt; Cont&lt; typename DerivedCont::value_type &gt;, DerivedCont &gt;::value &amp;&amp;<a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, typename DerivedCont::value_type &gt;::value &gt;::type *=NULL)</td></tr>
<tr class="separator:ab4bcf91e123479b0165baea4a8bfd518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539567d71e3aac19f688a33effe1a667"><td class="memTemplParams" colspan="2">template&lt;class Derived , class Base &gt; </td></tr>
<tr class="memitem:a539567d71e3aac19f688a33effe1a667"><td class="memTemplItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a539567d71e3aac19f688a33effe1a667">deprecated_cast</a> (const Base &amp;t, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a>, Base &gt;::value &amp;&amp;std::is_base_of&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a>, Derived &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a539567d71e3aac19f688a33effe1a667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast from an aterm derived term to another aterm.  <a href="#a539567d71e3aac19f688a33effe1a667">More...</a><br /></td></tr>
<tr class="separator:a539567d71e3aac19f688a33effe1a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf634f15e292dc560b97259fc550738"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#aeaf634f15e292dc560b97259fc550738">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;t)</td></tr>
<tr class="memdesc:aeaf634f15e292dc560b97259fc550738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the term in textual form to the ostream.  <a href="#aeaf634f15e292dc560b97259fc550738">More...</a><br /></td></tr>
<tr class="separator:aeaf634f15e292dc560b97259fc550738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed26edc94d42c9aa000b5780c06860"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#adbed26edc94d42c9aa000b5780c06860">pp</a> (const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;t)</td></tr>
<tr class="memdesc:adbed26edc94d42c9aa000b5780c06860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an aterm into a string representation.  <a href="#adbed26edc94d42c9aa000b5780c06860">More...</a><br /></td></tr>
<tr class="separator:adbed26edc94d42c9aa000b5780c06860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b503fd4127796e52cbe0355e5a1aaf"><td class="memTemplParams" colspan="2">template&lt;class Term &gt; </td></tr>
<tr class="memitem:a45b503fd4127796e52cbe0355e5a1aaf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a45b503fd4127796e52cbe0355e5a1aaf">pp</a> (const <a class="el" href="classatermpp_1_1term__balanced__tree.html">term_balanced_tree</a>&lt; Term &gt; t)</td></tr>
<tr class="separator:a45b503fd4127796e52cbe0355e5a1aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6c76c50b64749f983757f9b8960295"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a1e6c76c50b64749f983757f9b8960295">is_binary_aterm_stream</a> (std::istream &amp;is)</td></tr>
<tr class="separator:a1e6c76c50b64749f983757f9b8960295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6442f387ab3e3074e3c90d25e41d48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a8e6442f387ab3e3074e3c90d25e41d48">is_binary_aterm_file</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a8e6442f387ab3e3074e3c90d25e41d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3b5b8e0c9ab4cbc686f898ff56398f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a1c3b5b8e0c9ab4cbc686f898ff56398f">write_term_to_binary_stream</a> (const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;t, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a1c3b5b8e0c9ab4cbc686f898ff56398f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes term t to a stream in binary aterm format.  <a href="#a1c3b5b8e0c9ab4cbc686f898ff56398f">More...</a><br /></td></tr>
<tr class="separator:a1c3b5b8e0c9ab4cbc686f898ff56398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d3127c31653c895a1686db67d0546d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1aterm.html">aterm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a81d3127c31653c895a1686db67d0546d">read_term_from_binary_stream</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a81d3127c31653c895a1686db67d0546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a term from a stream in binary aterm format.  <a href="#a81d3127c31653c895a1686db67d0546d">More...</a><br /></td></tr>
<tr class="separator:a81d3127c31653c895a1686db67d0546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17a6fe9db897fd64828bbdc63433825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#ab17a6fe9db897fd64828bbdc63433825">write_term_to_text_stream</a> (const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;t, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ab17a6fe9db897fd64828bbdc63433825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes term t to a stream in textual format.  <a href="#ab17a6fe9db897fd64828bbdc63433825">More...</a><br /></td></tr>
<tr class="separator:ab17a6fe9db897fd64828bbdc63433825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495786c03e50921243b708d2582e7a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1aterm.html">aterm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a495786c03e50921243b708d2582e7a42">read_term_from_text_stream</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a495786c03e50921243b708d2582e7a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a term from a stream which contains the term in textual format.  <a href="#a495786c03e50921243b708d2582e7a42">More...</a><br /></td></tr>
<tr class="separator:a495786c03e50921243b708d2582e7a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b7a6a31298b49804016df4ed0efd03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1aterm.html">aterm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#aa2b7a6a31298b49804016df4ed0efd03">read_term_from_string</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:aa2b7a6a31298b49804016df4ed0efd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an aterm from a string. The string can be in either binary or text format.  <a href="#aa2b7a6a31298b49804016df4ed0efd03">More...</a><br /></td></tr>
<tr class="separator:aa2b7a6a31298b49804016df4ed0efd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6d09f72e0e1c4b1d8aef655a0ee541"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:a9c6d09f72e0e1c4b1d8aef655a0ee541"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a9c6d09f72e0e1c4b1d8aef655a0ee541">reverse</a> (const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;l)</td></tr>
<tr class="memdesc:a9c6d09f72e0e1c4b1d8aef655a0ee541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list with the elements in reversed order.  <a href="#a9c6d09f72e0e1c4b1d8aef655a0ee541">More...</a><br /></td></tr>
<tr class="separator:a9c6d09f72e0e1c4b1d8aef655a0ee541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b3b6b5cb0aefdfdd30b6169f533d05"><td class="memTemplParams" colspan="2">template&lt;typename Term1 , typename Term2 &gt; </td></tr>
<tr class="memitem:ac9b3b6b5cb0aefdfdd30b6169f533d05"><td class="memTemplItemLeft" align="right" valign="top">std::conditional&lt; std::is_convertible&lt; Term2, Term1 &gt;::value, <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term1 &gt;, <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#ac9b3b6b5cb0aefdfdd30b6169f533d05">operator+</a> (const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term1 &gt; &amp;l, const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term2 &gt; &amp;m)</td></tr>
<tr class="memdesc:ac9b3b6b5cb0aefdfdd30b6169f533d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the concatenation of two lists with convertible element types.  <a href="#ac9b3b6b5cb0aefdfdd30b6169f533d05">More...</a><br /></td></tr>
<tr class="separator:ac9b3b6b5cb0aefdfdd30b6169f533d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f294927d77e09bc1a74951768c459f"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:af3f294927d77e09bc1a74951768c459f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#af3f294927d77e09bc1a74951768c459f">push_back</a> (const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;l, const Term &amp;el)</td></tr>
<tr class="memdesc:af3f294927d77e09bc1a74951768c459f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element at the end of the list. Note that the complexity of this function is O(n), with n the number of elements in the list!!!  <a href="#af3f294927d77e09bc1a74951768c459f">More...</a><br /></td></tr>
<tr class="separator:af3f294927d77e09bc1a74951768c459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd45a01622b677a4121af75b0bf4c3eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classatermpp_1_1aterm__string.html">aterm_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#acd45a01622b677a4121af75b0bf4c3eb">empty_string</a> ()</td></tr>
<tr class="memdesc:acd45a01622b677a4121af75b0bf4c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the empty aterm string.  <a href="#acd45a01622b677a4121af75b0bf4c3eb">More...</a><br /></td></tr>
<tr class="separator:acd45a01622b677a4121af75b0bf4c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2592d32a8d4ccaea260f070a6dacb549"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:a2592d32a8d4ccaea260f070a6dacb549"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a2592d32a8d4ccaea260f070a6dacb549">remove_one_element</a> (const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;list, const Term &amp;t)</td></tr>
<tr class="separator:a2592d32a8d4ccaea260f070a6dacb549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2018bea9be8ee9f7666a5a96f6f97579"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a2018bea9be8ee9f7666a5a96f6f97579">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;<a class="el" href="hooks__test_8cpp.html#ad1351d85ffec3c1176dc31d8e8f8e28a">f</a>)</td></tr>
<tr class="memdesc:a2018bea9be8ee9f7666a5a96f6f97579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the name of a function symbol to an ostream.  <a href="#a2018bea9be8ee9f7666a5a96f6f97579">More...</a><br /></td></tr>
<tr class="separator:a2018bea9be8ee9f7666a5a96f6f97579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d34f4a3ca57fa78d1bcdd47ddf4fa"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a953d34f4a3ca57fa78d1bcdd47ddf4fa">pp</a> (const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;<a class="el" href="hooks__test_8cpp.html#ad1351d85ffec3c1176dc31d8e8f8e28a">f</a>)</td></tr>
<tr class="memdesc:a953d34f4a3ca57fa78d1bcdd47ddf4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the name of a function symbol as a string.  <a href="#a953d34f4a3ca57fa78d1bcdd47ddf4fa">More...</a><br /></td></tr>
<tr class="separator:a953d34f4a3ca57fa78d1bcdd47ddf4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ee6fe9bbf2a062ff4de374822e43c6"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:a29ee6fe9bbf2a062ff4de374822e43c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a29ee6fe9bbf2a062ff4de374822e43c6">term_list_union</a> (const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;v, const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;w)</td></tr>
<tr class="memdesc:a29ee6fe9bbf2a062ff4de374822e43c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of v and w.  <a href="#a29ee6fe9bbf2a062ff4de374822e43c6">More...</a><br /></td></tr>
<tr class="separator:a29ee6fe9bbf2a062ff4de374822e43c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4943960b516d93c12a5b666c45fcb43a"><td class="memTemplParams" colspan="2">template&lt;typename Term &gt; </td></tr>
<tr class="memitem:a4943960b516d93c12a5b666c45fcb43a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a4943960b516d93c12a5b666c45fcb43a">term_list_difference</a> (const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;v, const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;w)</td></tr>
<tr class="memdesc:a4943960b516d93c12a5b666c45fcb43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns v minus w.  <a href="#a4943960b516d93c12a5b666c45fcb43a">More...</a><br /></td></tr>
<tr class="separator:a4943960b516d93c12a5b666c45fcb43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcf85c650da833ae15d075e1adb561e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1aterm.html">aterm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a0dcf85c650da833ae15d075e1adb561e">read_term_from_binary_stream</a> (istream &amp;is)</td></tr>
<tr class="separator:a0dcf85c650da833ae15d075e1adb561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc553488e78d78de0282b2ad13c544bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatermpp_1_1aterm.html">aterm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#abc553488e78d78de0282b2ad13c544bc">read_term_from_text_stream</a> (istream &amp;is)</td></tr>
<tr class="separator:abc553488e78d78de0282b2ad13c544bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a879dfff70e08e68deb09994f2db6e1b5"><td class="memItemLeft" align="right" valign="top">const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatermpp.html#a879dfff70e08e68deb09994f2db6e1b5">max_len_of_short_list</a> =10000</td></tr>
<tr class="separator:a879dfff70e08e68deb09994f2db6e1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace for the aterm++ library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5b700cb63038bdfad10397351fca4b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classatermpp_1_1term__appl.html">term_appl</a>&lt;<a class="el" href="classatermpp_1_1aterm.html">aterm</a>&gt; <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">atermpp::aterm_appl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__appl_8h_source.html#l00291">291</a> of file <a class="el" href="aterm__appl_8h_source.html">aterm_appl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9713fa8ce931c3a2cd8aa5bfb75a1d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classatermpp_1_1term__balanced__tree.html">term_balanced_tree</a>&lt;<a class="el" href="classatermpp_1_1aterm.html">aterm</a>&gt; <a class="el" href="namespaceatermpp.html#a9713fa8ce931c3a2cd8aa5bfb75a1d1d">atermpp::aterm_balanced_tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classatermpp_1_1term__balanced__tree.html" title="Read-only balanced binary tree of terms. ">term_balanced_tree</a> with elements of type aterm. </p>

<p>Definition at line <a class="el" href="aterm__balanced__tree_8h_source.html#l00349">349</a> of file <a class="el" href="aterm__balanced__tree_8h_source.html">aterm_balanced_tree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa61bb12f97e6fedfb20a50cb6bc4342d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt;<a class="el" href="classatermpp_1_1aterm.html">aterm</a>&gt; <a class="el" href="namespaceatermpp.html#aa61bb12f97e6fedfb20a50cb6bc4342d">atermpp::aterm_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classatermpp_1_1term__list.html">term_list</a> with elements of type aterm. </p>

<p>Definition at line <a class="el" href="aterm__list_8h_source.html#l00326">326</a> of file <a class="el" href="aterm__list_8h_source.html">aterm_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a992fc95b7153020c7a6005380e05d18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::pair&lt;const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a>*,<a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a>&gt; &gt; <a class="el" href="namespaceatermpp.html#a992fc95b7153020c7a6005380e05d18d">atermpp::hook_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__implementation_8cpp_source.html#l00039">39</a> of file <a class="el" href="aterm__implementation_8cpp_source.html">aterm_implementation.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa8340a152b723553c64027b12195988b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* atermpp::term_callback) (const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00029">29</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abd26eb507fca62396cd1caf9f7850ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atermpp::add_creation_hook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__implementation_8cpp_source.html#l00053">53</a> of file <a class="el" href="aterm__implementation_8cpp_source.html">aterm_implementation.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6d8a98984bcc8e80186edc05b1e422e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atermpp::add_deletion_hook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatermpp.html#aa8340a152b723553c64027b12195988b">term_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__implementation_8cpp_source.html#l00067">67</a> of file <a class="el" href="aterm__implementation_8cpp_source.html">aterm_implementation.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae93a917e75091f807859dcf7b0e091cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename ReplaceFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Term atermpp::bottom_up_replace </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplaceFunction&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each subterm x of t by r(x). The ReplaceFunction r has the following signature: aterm_appl x; aterm_appl result = r(x); The replacements are performed in bottom up order. For example, replace(f(f(x)), f(x), x) returns x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">r</td><td>The replace function that is applied to subterms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the replacement. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00256">256</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1fc96c02d1c5f6f1bff2fe802b4e7205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Term atermpp::bottom_up_replace </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a> &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a> &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each subterm in t that is equal to old_value with new_value. The replacements are performed in top down order. For example, replace(f(f(x)), f(x), x) returns f(x) and not x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">old_value</td><td>The value of the subterm that is replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>The value that is substituted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the replacement. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00269">269</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c0632f02a15bcd3d95b74f45c2b14a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename ReplaceFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Term atermpp::bottom_up_replace </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplaceFunction&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a>, <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each subterm x of t by r(x). The ReplaceFunction r has the following signature: aterm_appl x; aterm_appl result = r(x); The replacements are performed in bottom up order. For example, replace(f(f(x)), f(x), x) returns x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">r</td><td>The replace function that is applied to subterms. </td></tr>
    <tr><td class="paramname">cache</td><td>A cache for the result of aterm_appl terms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the replacement. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00302">302</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff4eca5ee653f9c38bdc02606abb4ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedCont , typename Base , template&lt; typename Elem &gt; class Cont&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const DerivedCont&amp; atermpp::container_cast </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; Base &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__container.html">is_container</a>&lt; DerivedCont &gt;::value &amp;&amp;std::is_same&lt; Cont&lt; typename DerivedCont::value_type &gt;, DerivedCont &gt;::value &amp;&amp;!std::is_base_of&lt; DerivedCont, Cont&lt; Base &gt; &gt;::value &amp;&amp;<a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, typename DerivedCont::value_type &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00318">318</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a539567d71e3aac19f688a33effe1a667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , class Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Derived&amp; atermpp::deprecated_cast </td>
          <td>(</td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a>, Base &gt;::value &amp;&amp;std::is_base_of&lt; <a class="el" href="classatermpp_1_1aterm.html">aterm</a>, Derived &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast from an aterm derived term to another aterm. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>. </dd></dl>

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00361">361</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a02f5cf133903629de48bce98bcb9c205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , class Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Derived&amp; atermpp::down_cast </td>
          <td>(</td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, Derived &gt;::value &amp;&amp;!std::is_base_of&lt; Derived, Base &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cheap cast from one aterm based type to another When casting one aterm based type into another, generally a new aterm is constructed, and the old one is destroyed. This can cause undesired overhead, for instance due to increasing and decreasing of reference counts. This cast changes the type, without changing the aterm itself. It can only be used if Base and Derived inherit from aterm, and contain no additional information than a single aterm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term of a type inheriting from an aterm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A term of type Derived. </dd></dl>

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00308">308</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd45a01622b677a4121af75b0bf4c3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classatermpp_1_1aterm__string.html">aterm_string</a>&amp; atermpp::empty_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the empty aterm string. </p>

<p>Definition at line <a class="el" href="aterm__string_8h_source.html#l00081">81</a> of file <a class="el" href="aterm__string_8h_source.html">aterm_string.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8df8950ad9b80e31c056844b7352400a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename MatchPredicate , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void atermpp::find_all_if </td>
          <td>(</td>
          <td class="paramtype">const Term &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchPredicate&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all subterms of t that match a given predicate, and writes the found terms to the destination range starting with destBegin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">match</td><td>The predicate that determines if a subterm is a match </td></tr>
    <tr><td class="paramname">destBegin</td><td>The iterator range to which output is written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00197">197</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5f43e950f6b74d5433f66a5809d28f38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename MatchPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a> atermpp::find_if </td>
          <td>(</td>
          <td class="paramtype">const Term &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchPredicate&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a subterm of t that matches a given predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">match</td><td>The predicate that determines if a subterm is a match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subterm that matches the given predicate, or <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl()</a> if none was found. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00171">171</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a898b19ee30d566b679beb29155cb6c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction , typename Term &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction atermpp::for_each </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls op(elem) for subterms of the term t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">op</td><td>The operation that is applied to subterms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the (internally modified) op. The function op must have the signature bool op(aterm_appl t). When op(t) is false, the children of t are skipped. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00161">161</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e6442f387ab3e3074e3c90d25e41d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atermpp::is_binary_aterm_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__io__text_8cpp_source.html#l00467">467</a> of file <a class="el" href="aterm__io__text_8cpp_source.html">aterm_io_text.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e6c76c50b64749f983757f9b8960295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atermpp::is_binary_aterm_stream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__io__text_8cpp_source.html#l00455">455</a> of file <a class="el" href="aterm__io__text_8cpp_source.html">aterm_io_text.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9b3b6b5cb0aefdfdd30b6169f533d05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term1 , typename Term2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional&lt; std::is_convertible&lt; Term2, Term1 &gt;::value, <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term1 &gt;, <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term2 &gt; &gt;::type atermpp::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the concatenation of two lists with convertible element types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>A list. </td></tr>
    <tr><td class="paramname">m</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<p>The complexity of this operator is linear in the length of l. </p><dl class="section return"><dt>Returns</dt><dd>The concatenation of the lists l followed by m. </dd></dl>

<p>Definition at line <a class="el" href="aterm__list__implementation_8h_source.html#l00153">153</a> of file <a class="el" href="aterm__list__implementation_8h_source.html">aterm_list_implementation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2018bea9be8ee9f7666a5a96f6f97579"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; atermpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the name of a function symbol to an ostream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The out stream. </td></tr>
    <tr><td class="paramname">f</td><td>The function symbol to be output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. </dd></dl>

<p>Definition at line <a class="el" href="function__symbol_8h_source.html#l00270">270</a> of file <a class="el" href="function__symbol_8h_source.html">function_symbol.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeaf634f15e292dc560b97259fc550738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; atermpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the term in textual form to the ostream. </p>

<p>Definition at line <a class="el" href="aterm__io__text_8cpp_source.html#l00158">158</a> of file <a class="el" href="aterm__io__text_8cpp_source.html">aterm_io_text.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42adae5d62bb383d526ce6f704b35613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename MatchPredicate , typename StopPredicate , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void atermpp::partial_find_all_if </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchPredicate&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StopPredicate&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>destBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all subterms of t that match a given predicate, and writes the found terms to the destination range starting with destBegin. The term is only partially traversed. If the stop predicate returns true in a subterm, the recursion is not continued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">match</td><td>The predicate that determines if a subterm is a match </td></tr>
    <tr><td class="paramname">stop</td><td>The predicate that determines if the recursion should not be continued in a subterm </td></tr>
    <tr><td class="paramname">destBegin</td><td>The iterator range to which output is written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00212">212</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cc8c98070bdcd776cb2721ccc3632d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename MatchPredicate , typename StopPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl</a> atermpp::partial_find_if </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchPredicate&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StopPredicate&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a subterm of t that matches a given predicate. The term is only partially traversed. If the stop predicate returns true in a subterm, the recursion is not continued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">match</td><td>The predicate that determines if a subterm is a match </td></tr>
    <tr><td class="paramname">stop</td><td>The predicate that determines if the recursion should not be continued in a subterm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subterm that matches the given predicate, or <a class="el" href="namespaceatermpp.html#a5b700cb63038bdfad10397351fca4b05">aterm_appl()</a> if none was found. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00186">186</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a3a8b36a7b46d7f6c1d38aaae6341be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename ReplaceFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Term atermpp::partial_replace </td>
          <td>(</td>
          <td class="paramtype">Term&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplaceFunction&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces subterms x of t by r(x). The replace function r returns an additional boolean value. This value is used to prevent further recursion. The ReplaceFunction r has the following signature: aterm_appl x; std::pair&lt;aterm_appl, bool&gt; result = r(x); result.first is the result r(x) of the replacement result.second denotes if the recursion should be continued The replacements are performed in top down order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">r</td><td>The replace function that is applied to subterms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the replacement. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00286">286</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a953d34f4a3ca57fa78d1bcdd47ddf4fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; atermpp::pp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1function__symbol.html">function_symbol</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the name of a function symbol as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of r. </dd></dl>

<p>Definition at line <a class="el" href="function__symbol_8h_source.html#l00278">278</a> of file <a class="el" href="function__symbol_8h_source.html">function_symbol.h</a>.</p>

</div>
</div>
<a class="anchor" id="a45b503fd4127796e52cbe0355e5a1aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Term &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string atermpp::pp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__balanced__tree.html">term_balanced_tree</a>&lt; Term &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__balanced__tree_8h_source.html#l00352">352</a> of file <a class="el" href="aterm__balanced__tree_8h_source.html">aterm_balanced_tree.h</a>.</p>

</div>
</div>
<a class="anchor" id="adbed26edc94d42c9aa000b5780c06860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string atermpp::pp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform an aterm into a string representation. </p>
<p>This function also prints terms that are derived from aterms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input aterm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string. </dd></dl>

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00379">379</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3f294927d77e09bc1a74951768c459f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; atermpp::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Term &amp;&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element at the end of the list. Note that the complexity of this function is O(n), with n the number of elements in the list!!! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The list to which the term is appended. </td></tr>
    <tr><td class="paramname">el</td><td>A term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list l with elem appended at the end. </dd></dl>

<p>Definition at line <a class="el" href="aterm__list__implementation_8h_source.html#l00039">39</a> of file <a class="el" href="aterm__list__implementation_8h_source.html">aterm_list_implementation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a81d3127c31653c895a1686db67d0546d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1aterm.html">aterm</a> atermpp::read_term_from_binary_stream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a term from a stream in binary aterm format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>An input stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The term which is read. </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcf85c650da833ae15d075e1adb561e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1aterm.html">aterm</a> atermpp::read_term_from_binary_stream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__io__binary_8cpp_source.html#l00852">852</a> of file <a class="el" href="aterm__io__binary_8cpp_source.html">aterm_io_binary.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b7a6a31298b49804016df4ed0efd03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1aterm.html">aterm</a> atermpp::read_term_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an aterm from a string. The string can be in either binary or text format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The term corresponding to the string. </dd></dl>

<p>Definition at line <a class="el" href="aterm__io__text_8cpp_source.html#l00426">426</a> of file <a class="el" href="aterm__io__text_8cpp_source.html">aterm_io_text.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a495786c03e50921243b708d2582e7a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1aterm.html">aterm</a> atermpp::read_term_from_text_stream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a term from a stream which contains the term in textual format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>An input stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The term that is read from the input stream. </dd></dl>

</div>
</div>
<a class="anchor" id="abc553488e78d78de0282b2ad13c544bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1aterm.html">aterm</a> atermpp::read_term_from_text_stream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__io__text_8cpp_source.html#l00432">432</a> of file <a class="el" href="aterm__io__text_8cpp_source.html">aterm_io_text.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2592d32a8d4ccaea260f070a6dacb549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt;Term&gt; atermpp::remove_one_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Term &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__list__implementation_8h_source.html#l00107">107</a> of file <a class="el" href="aterm__list__implementation_8h_source.html">aterm_list_implementation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a00e12c8977c14259febf5a2fc0ba5815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term , typename ReplaceFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Term atermpp::replace </td>
          <td>(</td>
          <td class="paramtype">const Term &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplaceFunction&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each subterm x of t by r(x). The ReplaceFunction r has the following signature: aterm_appl x; aterm_appl result = r(x); The replacements are performed in top down order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">r</td><td>The replace function that is applied to subterms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the replacement. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00228">228</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13b2ad54448e868e63f214e77119ea63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Term atermpp::replace </td>
          <td>(</td>
          <td class="paramtype">const Term &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each subterm in t that is equal to old_value with new_value. The replacements are performed in top down order. For example, replace(f(f(x)), f(x), x) returns f(x) and not x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term </td></tr>
    <tr><td class="paramname">old_value</td><td>The subterm that will be replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>The value that will be substituted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the replacement. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8h_source.html#l00241">241</a> of file <a class="el" href="algorithm_8h_source.html">algorithm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c6d09f72e0e1c4b1d8aef655a0ee541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; atermpp::reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list with the elements in reversed order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator is linear in the size of the list. </p><dl class="section return"><dt>Returns</dt><dd>The reversed list. </dd></dl>

<p>Definition at line <a class="el" href="aterm__list__implementation_8h_source.html#l00094">94</a> of file <a class="el" href="aterm__list__implementation_8h_source.html">aterm_list_implementation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4943960b516d93c12a5b666c45fcb43a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt;Term&gt; atermpp::term_list_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns v minus w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A term list. </td></tr>
    <tr><td class="paramname">w</td><td>A term list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the term lists, interpreted as sets. </dd></dl>

<p>Definition at line <a class="el" href="set__operations_8h_source.html#l00047">47</a> of file <a class="el" href="set__operations_8h_source.html">set_operations.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29ee6fe9bbf2a062ff4de374822e43c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Term &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt;Term&gt; atermpp::term_list_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1term__list.html">term_list</a>&lt; Term &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the union of v and w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A term list. </td></tr>
    <tr><td class="paramname">w</td><td>A term list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the term lists, interpreted as sets. </dd></dl>

<p>Definition at line <a class="el" href="set__operations_8h_source.html#l00026">26</a> of file <a class="el" href="set__operations_8h_source.html">set_operations.h</a>.</p>

</div>
</div>
<a class="anchor" id="a819c47f61db4bf0134f12a54f4d355f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , class Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Derived&amp; atermpp::vertical_cast </td>
          <td>(</td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, Derived &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cast form an aterm derived class to a class that inherits in possibly multiple steps from this class. </p>
<p>The derived class is not allowed to contain extra fields. This conversion does not require runtime computation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The term that is converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A term of type Derived. </dd></dl>

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00337">337</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4bcf91e123479b0165baea4a8bfd518"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedCont , typename Base , template&lt; typename Elem &gt; class Cont&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const DerivedCont&amp; atermpp::vertical_cast </td>
          <td>(</td>
          <td class="paramtype">const Cont&lt; Base &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structatermpp_1_1is__container.html">is_container</a>&lt; DerivedCont &gt;::value &amp;&amp;std::is_same&lt; Cont&lt; typename DerivedCont::value_type &gt;, DerivedCont &gt;::value &amp;&amp;<a class="el" href="structatermpp_1_1is__convertible.html">is_convertible</a>&lt; Base, typename DerivedCont::value_type &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm_8h_source.html#l00346">346</a> of file <a class="el" href="aterm_8h_source.html">aterm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c3b5b8e0c9ab4cbc686f898ff56398f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atermpp::write_term_to_binary_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes term t to a stream in binary aterm format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term. </td></tr>
    <tr><td class="paramname">os</td><td>An output stream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aterm__io__binary_8cpp_source.html#l00666">666</a> of file <a class="el" href="aterm__io__binary_8cpp_source.html">aterm_io_binary.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab17a6fe9db897fd64828bbdc63433825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atermpp::write_term_to_text_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatermpp_1_1aterm.html">aterm</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes term t to a stream in textual format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A term. </td></tr>
    <tr><td class="paramname">os</td><td>An outputstream string </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aterm__io__text_8cpp_source.html#l00165">165</a> of file <a class="el" href="aterm__io__text_8cpp_source.html">aterm_io_text.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a879dfff70e08e68deb09994f2db6e1b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t atermpp::max_len_of_short_list =10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="aterm__list__implementation_8h_source.html#l00025">25</a> of file <a class="el" href="aterm__list__implementation_8h_source.html">aterm_list_implementation.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceatermpp.html">atermpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
